## 1. 面向对象的特征有哪些方面？
- 特征可以有上闹钟，继承、封装、多态；也可以说有四种，继承、封装、多态、抽象。
- 继承是类的一种层次模型，其提供了一种明确表述共性的方法，对象的新类可以从现有的类中继承派生，类可以从它的基类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特许的需要。
封装时把过程和数据包围起来，使得数据的访问只能通过已定义的接口，保证了对象访问的隐私性和可靠性。
- 多态性是对象在不同时刻表现出来的多种状态，是一种编译时期状态和运行时期不一致的现象，多态性包括参数化多态性和包含多态性。例如 JAVA 中父类变量指向子类对象的引用。多态的前提是唷继承关系。
- 抽象是指对一类事务的高度提炼以得到共同的部分，抽象不需要了解全部细节，而只是一种通用的描述约束，抽象可以是过程抽象或者数据抽象。

## 2. 多态的优缺点分别是什么？
- **多态的优点**：提高了代码的维护性和扩展性
- **缺点**：不能使用子类的特有功能    向下转型中有可能会出现异常

## 3. 在面向对象程序中，实现代码复用有继承和组合两种方式，请描述下这两种方式的区别。
- **继承**：复用父类的属性和方法，在编译期间就确定了类的层次结构，在实际编程中，不好的设计经常会导致父类中带有子类的行为，导致父类和子类互相依赖，丧失了重用的好处，破坏了封装。
- **组合**：在运行期间通过对象之间的引用动态定义相互间的关系，对象之间只能通过接口相互作用，对象的封装性也就得到了良好的维护，在运行期间，任何对象都能够被替换为其他相同类型的对象。
- 总而言之：优先使用组合，而不是继承。

## 4. 请写一段简单的代码，要求体现面向对象的特征。
```
class A {
  public String run(D obj) {
    return "a & d";
  }
  public String run(A obj) {
    return "a & a";
  }
}

class B extends A {
  public String run(B obj) {
    return "b & b";
  }
  public String run(A obj) {
    return "b & a";
  }
}

class C extends B {}
class D extends B {}

public class Test {
  public static void main(String[] args) {
    A aa = new A();
    A ab = new B();
    B b = new B();
    C c = new C();
    D d = new D();

    System.out.println(aa.run(b));
    System.out.println(aa.run(c));
    System.out.println(aa.run(d));

    System.out.println(ab.run(b));
    System.out.println(ab.run(c));
    System.out.println(ab.run(d));

    System.out.println(b.run(b));
    System.out.println(b.run(c));
    System.out.println(b.run(d));
  }
}
```
## 5. 请简述重载和重写的区别。
- **重载**：方法重载就是在一个类中可以创建多个方法，它们具有相同的名字，但是具有不同的参数和不同的定义，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，这就是多态性，重载的时候方法名一样，参数类型和个数不一样，返回值类型可以相同可以不同，可以有不同的访问修饰符，可以抛出不同的异常.
- **重写**：父类与子类之间的多态性，对父类的函数进行重新定义，如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写，在java中子类可以继承父类中的方法，而不需要重新编写相同的方法，但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要采用方法重写，方法重写又称方法覆盖  
若子类中的方法与父类中的某一方法具有相同的方法名，返回类型，参数列表，则新方法将覆盖原有的方法，如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类  
子类函数的访问修饰权限不能小于父类的  
重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查性异常（父类的异常宽泛性比子类的广）

## 6. 请简述 this 和 super 关键字的区别。
- **属性的区别**：this访问本类中的属性，如果本类没有此属性则从父类中继续查找。super访问父类中的属性。
- **方法的区别**：
 - super()主要是对父类构造函数的调用，this()是对重载构造函数的调用
 - super()主要是在继承了父类的子类的构造函数中使用，是在不同类中的使用；this()主要是在同一类的不同构造函数中的使用
 相同点：
 - super()和this()都必须在构造函数的第一行进行调用，否则就是错误的


## 7. int 和 Integer 都可以代表一个整数，为什么 JDK 设计了这两个类型？
int 是个原生类型，不是一个类，不能和其他面向对象的类进行交互，例如加入到一个 ArrayList 中。Integer 是对 int 的一个封装。

## 8. 代码输出结果
- 左边是一段问题代码，因为类 Hello 没有无参构造函数，无法使用 new Hello()
- 右边代码的输出结果是 null

## 10. 冒泡排序的三种实现
**实现 1 **
```
void bubbleSort(int a[], int n){
	for(int i =0 ; i< n-1; ++i) {
		for(int j = 0; j < n-i-1; ++j) {
			if(a[j] > a[j+1])
			{
				int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;
			}
		}
	}
}

```
**实现 2**
```
void Bubble_1 ( int r[], int n) {
	int i= n -1;  //初始时,最后位置保持不变
	while ( i> 0) {
		int pos= 0; //每趟开始时,无记录交换
		for (int j= 0; j< i; j++)
			if (r[j]> r[j+1]) {
				pos= j; //记录交换的位置
				int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;
			}
		i= pos; //为下一趟排序作准备
	 }
}  

```
**实现 3**
```
void Bubble_2 ( int r[], int n){
	int low = 0;
	int high= n -1; //设置变量的初始值
	int tmp,j;
	while (low < high) {
		for (j= low; j< high; ++j) //正向冒泡,找到最大者
			if (r[j]> r[j+1]) {
				tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;
			}
		--high;					//修改high值, 前移一位
		for ( j=high; j>low; --j) //反向冒泡,找到最小者
			if (r[j]<r[j-1]) {
				tmp = r[j]; r[j]=r[j-1];r[j-1]=tmp;
			}
		++low;					//修改low值,后移一位
	}
}

```
